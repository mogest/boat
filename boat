#!/usr/bin/ruby

require 'rubygems'
require 'hmac/sha2'

PORT = 19184
BOAT_VERSION = "0.1"

case command = ARGV.shift
when 'server'
  require 'eventmachine'
  require 'syslog'
  require 'digest'
  require 'fileutils'

  ROOT_PATH = File.expand_path(File.dirname(__FILE__))

  FileUtils.mkdir_p("#{ROOT_PATH}/tmp")

  module BoatServer
    include EventMachine::Protocols::LineText2
    NextCommand = Class.new(StandardError)
    @@last_connection_id = 0

    def post_init
      @@last_connection_id += 1
      @connection_id = @@last_connection_id
      @temporary_files = []
      send_data "220 Boat Server #{BOAT_VERSION}\n"
    end

    def receive_line(line)
      match = line.match(/\A(\S*)(.*)?/)
      command = match[1].downcase
      args = match[2].strip if match[2] && !match[2].strip.empty?

      begin
        if %w(user pass put get data confirm quit).include?(command)
          send("command_#{command}", args)
        else
          send_data "500 unknown command\n"
        end
      rescue NextCommand
      end
    end

    def command_user(args)
      if @authenticated
        send_data "500 already authenticated\n"
      elsif args.empty? || args.match(/[^a-z0-9_]/i)
        send_data "500 invalid username\n"
      else
        @username = args
        @salt = random_salt
        send_data "251 HMAC-SHA256 #{@salt}\n"
      end
    end

    def command_pass(args)
      if @authenticated
        send_data "500 already authenticated\n"
      elsif @username.nil? || @salt.nil?
        send_data "500 USER first\n"
      else
        user = Configuration.fetch("users", {}).fetch(@username, nil)
        expected = HMAC::SHA256.hexdigest(user["key"], @salt) if user
        if user && expected && args == expected
          send_data "250 OK\n"
          @user = user
          @authenticated = true
        else
          @username = @salt = nil
          send_data "401 invalid username or password\n"
        end
      end
    end

    def command_put(args)
      check_authenticated!

      if @user["access"] == "r"
        send_data "400 no write access\n"
      elsif @put_filename
        send_data "500 PUT already sent\n"
      elsif !args.match(/\A[a-z0-9_.%+-]+\z/i) # filenames should be urlencoded
        send_data "500 invalid filename\n"
      else
        repository_path = "#{ROOT_PATH}/repositories/#{@user["repository"]}"
        if @user.fetch("versioning", true) == false && File.exists?("#{repository_path}/current.#{args}")
          send_data "500 file already exists\n"
        else
          @put_filename = args
          send_data "250 OK\n"
        end
      end
    end

    def command_data(args)
      check_authenticated!

      if @put_filename.nil?
        send_data "500 PUT first\n"
      elsif @temporary_id
        send_data "500 DATA already sent\n"
      elsif !args.match(/\A[0-9]+\z/)
        send_data "500 invalid size\n"
      else
        size = args.to_i
        if size >= 1<<31
          send_data "500 size too large\n"
        else
          @temporary_id = "#{Time.now.to_i}.#{Process.pid}.#{@connection_id}"
          @temporary_filename = "#{ROOT_PATH}/tmp/#{@temporary_id}"
          @file_handle = File.open(@temporary_filename, "w")
          @temporary_files << @temporary_filename
          @digest = Digest::SHA256.new

          send_data "253 send #{size} bytes now\n"
          set_binary_mode size
        end
      end
    end

    def command_confirm(args)
      check_authenticated!

      if @put_file_salt.nil?
        send_data "500 DATA first\n"
      elsif args.nil? || (matches = args.match(/\A([0-9a-f]{64}) (\S+)\z/i)).nil?
        send_data "500 invalid hash\n"
      else
        received_client_hash = matches[1]
        received_salt = matches[2]

        expected_client_hash = HMAC::SHA256.hexdigest(@user["key"], "#{@put_file_salt}#{@put_file_hash}")
        if received_client_hash != expected_client_hash
          send_data "500 invalid confirmation hash\n"
          return
        end

        repository_path = "#{ROOT_PATH}/repositories/#{@user["repository"]}"
        FileUtils.mkdir_p(repository_path)
        version_filename = "#{repository_path}/#{@temporary_id}.#{@put_filename}"
        symlink_name = "#{repository_path}/current.#{@put_filename}"

        if @user.fetch("versioning", true) == false && File.exists?(symlink_name)
          send_data "500 file with same filename was uploaded before this upload completed\n"
          File.unlink(@temporary_filename)
          @temporary_files.delete(@temporary_filename)
          return
        end

        File.rename(@temporary_filename, version_filename)
        @temporary_files.delete(@temporary_filename)
        begin
          File.unlink(symlink_name) if File.symlink?(symlink_name)
        rescue Errno::ENOENT
        end
        File.symlink(version_filename, symlink_name)

        hash = HMAC::SHA256.hexdigest(@user["key"], "#{received_salt}#{@put_file_hash}")
        send_data "255 accepted #{hash}\n"

        @file_handle = @put_filename = @temporary_filename = @temporary_id = @put_file_salt = @put_file_hash = nil
      end
    end

    def command_get(args)
      check_authenticated!
      send_data "500 not implemented\n"
    end

    def command_quit(args)
      send_data "221 bye\n"
      close_connection_after_writing
    end

    def check_authenticated!
      unless @authenticated
        send_data "500 not authenticated\n"
        raise NextCommand
      end
    end

    def receive_binary_data(data)
      @file_handle.write data
      @digest << data
    end

    def receive_end_of_binary_data
      @file_handle.close
      @put_file_hash = @digest.to_s
      @put_file_salt = random_salt
      @digest = nil

      send_data "254 confirm #{@put_file_hash} #{@put_file_salt}\n"
    end

    def unbind
      @temporary_files.each do |filename|
        begin
          File.unlink(filename)
        rescue Errno::ENOENT
        end
      end
    end

    def random_salt
      [Digest::SHA256.digest((0..64).inject("") {|r, i| r << rand(256).chr})].pack("m").strip
    end
  end

  trap('SIGINT') { exit }
  trap('SIGTERM') { exit }

  while ARGV.first && ARGV.first[0..0] == '-' && ARGV.first.length > 1
    case opt = ARGV.shift
    when '-c'
      config_file = ARGV.shift

    else
      raise "unknown commandline option #{opt}"
    end
  end

  config_file ||= "/etc/boat.conf"
  unless File.exists?(config_file)
    raise "configuration file #{config_file} does not exist"
  end

  Configuration = YAML.load(IO.read(config_file))
  if Configuration["users"].nil? || Configuration["users"].empty?
    raise "configuration file does not have any users defined in it"
  end

  #Syslog.open 'boat'

  File.umask(0077)
  EventMachine.run do
    EventMachine.start_server Configuration.fetch("listen_address", "localhost"), Configuration.fetch("listen_port", PORT), BoatServer
  end

when 'put'
  require 'socket'
  require 'cgi'
  require 'yaml'

  class BoatClient
    Error = Class.new(StandardError)

    def initialize(username, key, host, opts = {})
      port = opts.fetch(:port, PORT)
      @key = key
      @debug = opts.fetch(:debug, false)
      @chunk_size = opts.fetch(:chunk_size, 1048576)

      puts "[debug] connecting to #{host} port #{port}" if @debug
      @socket = TCPSocket.new(host, port)
      response = @socket.gets
      raise Error, response unless response =~ /^220/

      puts "[debug] sending username" if @debug
      @socket.puts "user #{username}"
      response = @socket.gets
      raise Error, response unless response =~ /^251 HMAC-SHA256 (.+)/

      puts "[debug] sending password" if @debug
      password_hash = HMAC::SHA256.hexdigest(key, $1)
      @socket.puts "pass #{password_hash}"
      response = @socket.gets
      raise Error, response unless response =~ /^250/
    end

    def put(io, filename, size = nil)
      encoded_filename = CGI.escape(filename)
      puts "[debug] sending put command with filename #{encoded_filename}" if @debug
      @socket.puts "put #{encoded_filename}"
      response = @socket.gets
      raise Error, response unless response =~ /^250/

      if size.nil?
        size = io.respond_to?(:stat) ? io.stat.size : io.length
      end

      puts "[debug] sending data command" if @debug
      @socket.puts "data #{size}"
      response = @socket.gets
      raise Error, response unless response =~ /^253/

      digest = Digest::SHA256.new

      if io.respond_to?(:read)
        written = 0
        while data = io.read(@chunk_size)
          if @debug
            print "[debug] sending data (#{written} / #{size} bytes)\r"
            STDOUT.flush
          end
          digest << data
          @socket.write(data)
          written += data.length
        end
      else
        puts "[debug] sending data" if @debug
        @socket.write(io)
        digest << io
      end

      puts "[debug] data sent (#{size} bytes); waiting for response" if @debug
      response = @socket.gets
      raise Error, response unless response && matches = response.strip.match(/\A254 confirm ([0-9a-f]{64}) (\S+)\z/i)

      if matches[1] != digest.to_s
        raise Error, "Server reports file hash #{matches[1]} but we calculated hash #{digest.to_s}"
      end

      confirm_hash = HMAC::SHA256.hexdigest(@key, "#{matches[2]}#{digest.to_s}")
      confirm_salt = [Digest::SHA256.digest((0..64).inject("") {|r, i| r << rand(256).chr})].pack("m").strip
      puts "[debug] sending confirm command" if @debug
      @socket.puts "confirm #{confirm_hash} #{confirm_salt}\n"
      response = @socket.gets
      raise Error, response unless response && matches = response.strip.match(/\A255 accepted ([0-9a-f]{64})\z/i)

      confirm_hash = HMAC::SHA256.hexdigest(@key, "#{confirm_salt}#{digest.to_s}")
      if matches[1] != confirm_hash
        raise Error, "Server reports confirmation hash #{matches[1]} but we calculated hash #{confirm_hash}"
      end

      size
    end

    def quit
      puts "[debug] sending quit" if @debug
      @socket.puts "quit"
      response = @socket.gets
      @socket.close
    end
  end

  while ARGV.first && ARGV.first[0..0] == '-' && ARGV.first.length > 1
    case opt = ARGV.shift
    when '-v'
      debug = true

    when '-c'
      config_file = ARGV.shift

    else
      raise "unknown commandline option #{opt}"
    end
  end

  filename, destination_filename = ARGV

  if filename == '-' && destination_filename.to_s.empty?
    raise "you must specify a destination_filename if you are uploading from stdin"
  end

  destination_filename ||= File.basename(filename)
  config_file ||= "#{ENV['HOME']}/.boat.yml"

  unless File.exists?(config_file)
    raise "#{config_file} does not exist.  run boat configure"
  end

  configuration = YAML.load(IO.read(config_file))

  if filename != '-' && !File.exists?(filename)
    raise "#{filename} doesn't exist"
  end

  begin
    client = BoatClient.new(configuration["username"], configuration["key"], configuration["host"], :debug => debug)
    if filename == '-'
      client.put(STDIN, destination_filename)
    else
      File.open(filename, "r") {|file| client.put(file, destination_filename)}
    end
    client.quit
  rescue BoatClient::Error => e
    STDERR.puts e.message
    exit(1)
  end


when 'configure', 'config'
  config_file = ARGV.first || "#{ENV['HOME']}/.boat.yml"

  configuration = File.exists?(config_file) ? YAML.load(IO.read(config_file)) : {}
  puts "Configuring #{config_file}\n\n"

  [["Username", "username"], ["Key", "key"], ["Hostname", "host"]].each do |title, key|
    print "#{title} [#{configuration[key]}] "
    input = STDIN.gets.strip
    configuration[key] = input unless input.empty?
  end

  File.open(config_file, "w") {|file| file.write configuration.to_yaml}


else
  puts "Unknown command #{command}\n\n" if command && !command.empty? && command != 'help'

  puts <<-EOT
Boat #{BOAT_VERSION}
Copyright 2011 Roger Nesbitt

Boat is a file transfer server and client, made for backing up files.

Server usage:

    boat server [-c config_file]
        Starts the boat server.
        Uses /etc/boat.conf if config_file is not specified.

Client usage:

    boat configure [config_file]
        Configures the username, key and hostname to use.  If no config
        file is specified, ~/.boat.yml is used by default.

    boat put [-v] [-c config_file] source_filename [destination_filename]
        Uploads source_filename to the remote server.
        source_filename may be '-' to upload from stdin, but in this case
        a destination_filename must be specified.

  EOT
end
